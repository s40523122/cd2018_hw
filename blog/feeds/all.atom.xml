<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>40523122的個人作業Blog</title><link href="./" rel="alternate"></link><link href="./feeds/all.atom.xml" rel="self"></link><id>./</id><updated>2018-05-29T12:03:00+08:00</updated><entry><title>繪製組合轉動正齒輪</title><link href="./22_gear3.html" rel="alternate"></link><published>2018-05-29T12:03:00+08:00</published><updated>2018-05-29T12:03:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2018-05-29:./22_gear3.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="cango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="na" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="nb" value="25"&gt;&lt;/input&gt;&lt;br /&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# 以 button 驅動的事件函式
def setgearnumber(e):

    x = 800/2
    y = 700/2
    if doc["na"].value.isdigit():
        n = int(doc["na"].value)
    else:
        n = 50

    if doc["nb"].value.isdigit():
        n2 = int(doc["nb"].value)
    else:
        n2 = 25
    def cangoGear(n, m, pa):
        # m 為模數, 根據畫布的寬度, 計算適合的模數大小
        # Module = mm of pitch diameter per tooth
        #m = 0.8*canvas.width/n
        # pr 為節圓半徑
        pr = n*m/2 # gear Pitch radius
        # generate gear
        data = creategeartooth(m, n, pa)
        # Brython 程式中的 print 會將資料印在 Browser 的 console 區
        #print(data)
        gearTooth = shape(data, {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
        gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
        # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
        gear = gearTooth.dup()
        # gear 為單一齒的輪廓資料
        #cgo.render(gearTooth)

        # 利用單齒輪廓旋轉, 產生整個正齒輪外形
        for i in range(1, n):
            # 將 gearTooth 中的資料複製到 newTooth
            newTooth = gearTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            gear.appendPath(newTooth, True) # trim move command = True

        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = path(shapedefs.circle(hr))
        shaft.revWinding()
        gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

        # setup the animation
        # backlash (mm)
        bklsh = 0.04*m
        # centre shift to make backlash
        dC = bklsh/(2*math.tan(math.pi*pa/180))
        # np 為小齒輪齒數
        np = 25
        # gear ratio
        gr = n/np              
        gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
        # gr*0.666 rpm
        #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
        # 0.666 rpm
        return gear

    # 設定兩齒齒數
    reduced_ratio = 0.5
    # 使用 80% 的畫布寬度
    m = 0.8*canvas.width/((n+n2)*reduced_ratio)
    # 設定共同的壓力角
    pa = 20
    # n 齒輪的節圓半徑
    pr = n*m/2
    # n2 齒輪的節圓半徑
    pr2 = n2*m/2

    from time import time
    from browser.timer import request_animation_frame as raf
    from browser.timer import set_interval

    deg = math.pi/180

    def draw():
        cgo.clearCanvas()
        gear.rotate(2*deg)
        # 在特定位置, 以特定 scale, 特定 degs 執行 render
        # 設定囓合點在畫布正中央
        # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標
        #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0})
        cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0})
        # 根據兩齒輪齒數比決定 n2 齒輪轉速
        gear1.rotate(-2*deg*n/n2)

        # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合
        cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)})
    set_interval(draw, 2)

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r17 = canvas_size*n2/(n+n2)
    r11 = r17*n2/n
    # 計算各齒輪中心座標
    x17 = x -r17
    y17 = y

    x11 = x +r11
    y11 = y
    pa = 20

    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x17, y17)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x17, -y17)
    gear = cangoGear(n, m, pa)
    cx = canvas.width/2 + 4 * n
    cy = canvas.height/2
    # 回復原有的座標系統
    ctx.restore()
    ctx.save()
    ctx.translate(x11, y11)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x11, -y11)
    gear1 = cangoGear(n2, m, pa)
    ctx.restore()

setgearnumber(True)
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;h4&gt;程式碼如下:&lt;/h4&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="cango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="na" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="nb" value="25"&gt;&lt;/input&gt;&lt;br /&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# 以 button 驅動的事件函式
def setgearnumber(e):

    x = 800/2
    y = 700/2
    if doc["na"].value.isdigit():
        n = int(doc["na"].value)
    else:
        n = 50

    if doc["nb"].value.isdigit():
        n2 = int(doc["nb"].value)
    else:
        n2 = 25
    def cangoGear(n, m, pa):
        # m 為模數, 根據畫布的寬度, 計算適合的模數大小
        # Module = mm of pitch diameter per tooth
        #m = 0.8*canvas.width/n
        # pr 為節圓半徑
        pr = n*m/2 # gear Pitch radius
        # generate gear
        data = creategeartooth(m, n, pa)
        # Brython 程式中的 print 會將資料印在 Browser 的 console 區
        #print(data)
        gearTooth = shape(data, {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
        gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
        # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
        gear = gearTooth.dup()
        # gear 為單一齒的輪廓資料
        #cgo.render(gearTooth)

        # 利用單齒輪廓旋轉, 產生整個正齒輪外形
        for i in range(1, n):
            # 將 gearTooth 中的資料複製到 newTooth
            newTooth = gearTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            gear.appendPath(newTooth, True) # trim move command = True

        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = path(shapedefs.circle(hr))
        shaft.revWinding()
        gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

        # setup the animation
        # backlash (mm)
        bklsh = 0.04*m
        # centre shift to make backlash
        dC = bklsh/(2*math.tan(math.pi*pa/180))
        # np 為小齒輪齒數
        np = 25
        # gear ratio
        gr = n/np              
        gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
        # gr*0.666 rpm
        #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
        # 0.666 rpm
        return gear

    # 設定兩齒齒數
    reduced_ratio = 0.5
    # 使用 80% 的畫布寬度
    m = 0.8*canvas.width/((n+n2)*reduced_ratio)
    # 設定共同的壓力角
    pa = 20
    # n 齒輪的節圓半徑
    pr = n*m/2
    # n2 齒輪的節圓半徑
    pr2 = n2*m/2

    from time import time
    from browser.timer import request_animation_frame as raf
    from browser.timer import set_interval

    deg = math.pi/180

    def draw():
        cgo.clearCanvas()
        gear.rotate(2*deg)
        # 在特定位置, 以特定 scale, 特定 degs 執行 render
        # 設定囓合點在畫布正中央
        # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標
        #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0})
        cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0})
        # 根據兩齒輪齒數比決定 n2 齒輪轉速
        gear1.rotate(-2*deg*n/n2)

        # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合
        cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)})
    set_interval(draw, 2)

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r17 = canvas_size*n2/(n+n2)
    r11 = r17*n2/n
    # 計算各齒輪中心座標
    x17 = x -r17
    y17 = y

    x11 = x +r11
    y11 = y
    pa = 20

    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x17, y17)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x17, -y17)
    gear = cangoGear(n, m, pa)
    cx = canvas.width/2 + 4 * n
    cy = canvas.height/2
    # 回復原有的座標系統
    ctx.restore()
    ctx.save()
    ctx.translate(x11, y11)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x11, -y11)
    gear1 = cangoGear(n2, m, pa)
    ctx.restore()

setgearnumber(True)
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;/pre&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>繪製靜態組合正齒輪</title><link href="./22_gear2.html" rel="alternate"></link><published>2018-05-28T12:01:00+08:00</published><updated>2018-05-28T12:01:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2018-05-28:./22_gear2.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;2-1 使用 canvas 畫出一個可自選齒數並組合之靜態正齒輪&lt;/h2&gt;
&lt;p&gt;&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="ronegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="ronegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="rn1" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="rn2" value="25"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="rbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()

    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, rn 為齒數
    # pa 為壓力角 (deg)
    # 已經針對 rn 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, rn=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/rn
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/rn
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*rn)+math.tan(pa*deg)-pa*deg
        for j in range(rn):
            ang=-2.*j*math.pi/rn+sigma
            ang2=2.*j*math.pi/rn+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/rn)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/rn)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['ronegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def set(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["rn1"].value.isdigit():
        n1 = int(doc["rn1"].value)
    else:
        n1 = 50

    if doc["rn2"].value.isdigit():
        n2 = int(doc["rn2"].value)
    else:
        n2 = 25


    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r1 = canvas_size*0.8
    r2 = r1 * n2 / n1

    # 計算各齒輪中心座標
    x1 = x - r1
    y1 = y

    x2 = x+r2 
    y2 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x1, y1)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x1, -y1)
    gear1 = Spur(ctx).Gear(x1, y1, r1, n1, pa, "blue")
    # 回復原有的座標系統
    ctx.restore()

    ctx.save()
    ctx.translate(x2, y2)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x2, -y2)
    gear2 = Spur(ctx).Gear(x2, y2, r2, n2, pa, "blue")
    ctx.restore()

set(True)
doc['rbutton'].bind('click',set)
&lt;/script&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;程式碼如下:　　　　　&lt;a href="#p3"&gt;&lt;font color="#FF00FF"&gt;跳過程式碼請點此&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="ronegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="ronegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="rn1" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="rn2" value="25"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="rbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, rn 為齒數
    # pa 為壓力角 (deg)
    # 已經針對 rn 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, rn=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/rn
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/rn
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*rn)+math.tan(pa*deg)-pa*deg
        for j in range(rn):
            ang=-2.*j*math.pi/rn+sigma
            ang2=2.*j*math.pi/rn+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/rn)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/rn)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['ronegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def set(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["rn1"].value.isdigit():
        n1 = int(doc["rn1"].value)
    else:
        n1 = 50

    if doc["rn2"].value.isdigit():
        n2 = int(doc["rn2"].value)
    else:
        n2 = 25


    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r1 = canvas_size*0.8
    r2 = r1 * n2 / n1

    # 計算各齒輪中心座標
    x1 = x - r1
    y1 = y

    x2 = x+r2 
    y2 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x1, y1)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x1, -y1)
    gear1 = Spur(ctx).Gear(x1, y1, r1, n1, pa, "blue")
    # 回復原有的座標系統
    ctx.restore()

    ctx.save()
    ctx.translate(x2, y2)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x2, -y2)
    gear2 = Spur(ctx).Gear(x2, y2, r2, n2, pa, "blue")
    ctx.restore()

set(True)
doc['rbutton'].bind('click',set)
&lt;/script&gt;

&lt;p&gt;&lt;/pre&gt;
&lt;a id="p3"&gt;&lt;/a&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;2-2 使用事先建立好的 cango 程式庫畫出兩個可自選齒數並組合之靜態正齒輪&lt;/h2&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='rcango_gear' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="rcango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="rcn1" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="rcn2" value="25"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="rcbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["rcango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("rcango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# 以 button 驅動的事件函式
def set1(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = 800/2
    y = 700/2
    if doc["rcn1"].value.isdigit():
        n = int(doc["rcn1"].value)
    else:
        n = 50

    if doc["rcn2"].value.isdigit():
        n2 = int(doc["rcn2"].value)
    else:
        n2 = 25
    def cangoGear(n, m, pa):
        # n 為齒數
        # pa 為壓力角
        #pa = 25
        # m 為模數, 根據畫布的寬度, 計算適合的模數大小
        # Module = mm of pitch diameter per tooth
        # pr 為節圓半徑
        pr = n*m/2 # gear Pitch radius
        # generate gear
        data = creategeartooth(m, n, pa)
        # Brython 程式中的 print 會將資料印在 Browser 的 console 區
        #print(data)
        gearTooth = shape(data, {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
        gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
        # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
        gear = gearTooth.dup()

        # 利用單齒輪廓旋轉, 產生整個正齒輪外形
        for i in range(1, n):
            # 將 gearTooth 中的資料複製到 newTooth
            newTooth = gearTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            gear.appendPath(newTooth, True) # trim move command = True

        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = path(shapedefs.circle(hr))
        shaft.revWinding()
        gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

        # setup the animation
        # backlash (mm)
        bklsh = 0.04*m
        # centre shift to make backlash
        dC = bklsh/(2*math.tan(math.pi*pa/180))
        # np 為小齒輪齒數
        np = 25
        # gear ratio
        gr = n/np              
        gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
        # gr*0.666 rpm
        #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
        # 0.666 rpm
        return gear

    reduced_ratio = 0.5
    # 使用 80% 的畫布寬度
    m = 0.8*canvas.width/((n+n2)*reduced_ratio)
    # n 齒輪的節圓半徑
    pr = n*m/2
    # n2 齒輪的節圓半徑
    pr2 = pr * n2 / n
    deg = math.pi/180

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.8
    r1 = canvas_size*0.6
    r2 = r1 * n2 / n
    # 計算各齒輪中心座標
    x1 = x 
    y1 = y

    x2 = x +r2+ r1/2
    y2 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x1, y1)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x1, -y1)
    # 建立 gear
    gear = cangoGear(n, m, pa)
    ctx.restore()
    cx = canvas.width/2 + 4 * n
    cy = canvas.height/2

    # 回復原有的座標系統
    ctx.restore()
    ctx.save()
    ctx.translate(x2, y2)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x2, -y2)
    # 建立 gear1
    gear1 = cangoGear(n2, m, pa)
    ctx.restore()

    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    # 設定囓合點在畫布正中央
    # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標
    #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0})
    cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0})
    # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合
    cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)})

set1(True)
doc['rcbutton'].bind('click',set1)
&lt;/script&gt;

&lt;h4&gt;程式碼如下:&lt;/h4&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='rcango_gear' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="rcango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="rcn1" value="50"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="rcn2" value="25"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="rcbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["rcango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("rcango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# 以 button 驅動的事件函式
def set1(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = 800/2
    y = 700/2
    if doc["rcn1"].value.isdigit():
        n = int(doc["rcn1"].value)
    else:
        n = 50

    if doc["rcn2"].value.isdigit():
        n2 = int(doc["rcn2"].value)
    else:
        n2 = 25
    def cangoGear(n, m, pa):
        # n 為齒數
        # pa 為壓力角
        #pa = 25
        # m 為模數, 根據畫布的寬度, 計算適合的模數大小
        # Module = mm of pitch diameter per tooth
        # pr 為節圓半徑
        pr = n*m/2 # gear Pitch radius
        # generate gear
        data = creategeartooth(m, n, pa)
        # Brython 程式中的 print 會將資料印在 Browser 的 console 區
        #print(data)
        gearTooth = shape(data, {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
        gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
        # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
        gear = gearTooth.dup()

        # 利用單齒輪廓旋轉, 產生整個正齒輪外形
        for i in range(1, n):
            # 將 gearTooth 中的資料複製到 newTooth
            newTooth = gearTooth.dup()
            # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
            newTooth.rotate(360*i/n)
            # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
            gear.appendPath(newTooth, True) # trim move command = True

        # 建立軸孔
        # add axle hole, hr 為 hole radius
        hr = 0.6*pr # diameter of gear shaft
        shaft = path(shapedefs.circle(hr))
        shaft.revWinding()
        gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

        # setup the animation
        # backlash (mm)
        bklsh = 0.04*m
        # centre shift to make backlash
        dC = bklsh/(2*math.tan(math.pi*pa/180))
        # np 為小齒輪齒數
        np = 25
        # gear ratio
        gr = n/np              
        gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
        # gr*0.666 rpm
        #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
        # 0.666 rpm
        return gear

    reduced_ratio = 0.5
    # 使用 80% 的畫布寬度
    m = 0.8*canvas.width/((n+n2)*reduced_ratio)
    # n 齒輪的節圓半徑
    pr = n*m/2
    # n2 齒輪的節圓半徑
    pr2 = pr * n2 / n
    deg = math.pi/180

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.8
    r1 = canvas_size*0.6
    r2 = r1 * n2 / n
    # 計算各齒輪中心座標
    x1 = x 
    y1 = y

    x2 = x +r2+ r1/2
    y2 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x1, y1)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x1, -y1)
    # 建立 gear
    gear = cangoGear(n, m, pa)
    ctx.restore()
    cx = canvas.width/2 + 4 * n
    cy = canvas.height/2

    # 回復原有的座標系統
    ctx.restore()
    ctx.save()
    ctx.translate(x2, y2)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n2)
    ctx.translate(-x2, -y2)
    # 建立 gear1
    gear1 = cangoGear(n2, m, pa)
    ctx.restore()

    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    # 設定囓合點在畫布正中央
    # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標
    #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0})
    cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0})
    # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合
    cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)})

set1(True)
doc['rcbutton'].bind('click',set1)
&lt;/script&gt;

&lt;/pre&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>繪製靜態正齒輪</title><link href="./22_gear1.html" rel="alternate"></link><published>2018-05-27T12:00:00+08:00</published><updated>2018-05-27T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2018-05-27:./22_gear1.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h2&gt;1-1 使用 canvas 畫出一個可自選齒數之靜態正齒輪&lt;/h2&gt;
&lt;p&gt;&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="n" value="22"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()

    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n"].value.isdigit():
        n1 = int(doc["n"].value)
    else:
        n1= 22
    # 設定齒輪參數
    x = (canvas.width)/2
    y = (canvas.height)/2
    r = 0.6*(canvas.height/2)
    pa = 20
    # 繪出齒輪
    Spur(ctx).Gear(x, y, r, n1, pa, "blue")
#判定 button
setgearnumber(True)
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;程式碼如下:　　　　　&lt;a href="#p1"&gt;&lt;font color="#FF00FF"&gt;跳過程式碼請點此&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="n" value="22"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()

    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n"].value.isdigit():
        n1 = int(doc["n"].value)
    else:
        n1= 22
    # 設定齒輪參數
    x = (canvas.width)/2
    y = (canvas.height)/2
    r = 0.6*(canvas.height/2)
    pa = 20
    # 繪出齒輪
    Spur(ctx).Gear(x, y, r, n1, pa, "blue")
#判定 button
setgearnumber(True)
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;p&gt;&lt;/pre&gt;
&lt;a id="p1"&gt;&lt;/a&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;1-2 使用事先建立好的 cango 程式庫畫出一個可自選齒數之靜態正齒輪&lt;/h2&gt;
&lt;p&gt;&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="../cango/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="cango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="cn" value="22"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="cbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = window.Cobj.new
creategeartooth = window.createGearTooth.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################

# 以 button 驅動的事件函式
def draw(e):
    cgo.clearCanvas()
    cx = (canvas.width)/2
    cy = (canvas.height)/2
    if doc["cn"].value.isdigit():
        cn1 = int(doc["cn"].value)
    else:
        cn1= 22
# pa 為壓力角
    pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
    m = 0.5*canvas.width/cn1
# pr 為節圓半徑
    pr = cn1*m/2 # gear Pitch radius
# generate gear
    data = creategeartooth(m, cn1, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
    gearTooth = cobj(data, "SHAPE", {
            "fillColor":"#ddd0dd",
                    "border": True,
           "strokeColor": "#606060" })
    gearTooth.rotate(180/cn1) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, cn1):
    # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/cn1)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
        gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = cobj(shapedefs.circle(hr), "PATH")
    shaft.revWinding()
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# render 繪出靜態正齒輪輪廓
    gear.translate(cx, cy)
    cgo.render(gear)
    r = 0.6*(canvas.height/2)
draw(True)
doc['cbutton'].bind('click',draw)
&lt;/script&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;程式碼如下:&lt;/h4&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="../cango/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="../cango/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;!-- 以下製作 button--&gt;

&lt;div id="cango_gear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="cn" value="22"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="cbutton"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = window.Cobj.new
creategeartooth = window.createGearTooth.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################

# 以 button 驅動的事件函式
def draw(e):
    cgo.clearCanvas()
    cx = (canvas.width)/2
    cy = (canvas.height)/2
    if doc["cn"].value.isdigit():
        cn1 = int(doc["cn"].value)
    else:
        cn1= 22
# pa 為壓力角
    pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
    m = 0.5*canvas.width/cn1
# pr 為節圓半徑
    pr = cn1*m/2 # gear Pitch radius
# generate gear
    data = creategeartooth(m, cn1, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
    gearTooth = cobj(data, "SHAPE", {
            "fillColor":"#ddd0dd",
                    "border": True,
           "strokeColor": "#606060" })
    gearTooth.rotate(180/cn1) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, cn1):
    # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/cn1)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
        gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = cobj(shapedefs.circle(hr), "PATH")
    shaft.revWinding()
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# render 繪出靜態正齒輪輪廓
    gear.translate(cx, cy)
    cgo.render(gear)
    r = 0.6*(canvas.height/2)
draw(True)
doc['cbutton'].bind('click',draw)
&lt;/script&gt;

&lt;p&gt;&lt;/pre&gt;
&lt;a id="p2"&gt;&lt;/a&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>W16課後整理</title><link href="./Course_W16_22.html" rel="alternate"></link><published>2017-10-28T12:00:00+08:00</published><updated>2017-10-28T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-28:./Course_W16_22.html</id><summary type="html">&lt;p&gt;附上小組軌道成果
</summary><content type="html">&lt;p&gt;附上小組軌道成果
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;連結&lt;/h2&gt;&lt;br/&gt;
小組倉儲:&lt;br/&gt;
&lt;font color="#0066FF"&gt;&lt;a href="https://github.com/s40523122/ag5_cadp_finalproject"&gt;https://github.com/s40523122/ag5_cadp_finalproject&lt;/a&gt; &lt;/font&gt;&lt;br/&gt;
小組PDF簡報:&lt;br/&gt;
&lt;font color="#0066FF"&gt;&lt;a href="https://github.com/s40523122/ag5_cadp_finalproject/blob/gh-pages/report/words/group%20report/%E9%8B%BC%E7%90%83%E9%81%8B%E5%8B%95%E6%A9%9F%E6%A7%8B.pdf"&gt;https://github.com/s40523122/ag5_cadp_finalproject/blob/gh-pages/report/words/group%20report/%E9%8B%BC%E7%90%83%E9%81%8B%E5%8B%95%E6%A9%9F%E6%A7%8B.pdf&lt;/a&gt; &lt;/font&gt;&lt;br/&gt;
小組onshape:&lt;br/&gt;
&lt;font color="#0066FF"&gt;&lt;a href="https://cad.onshape.com/documents/7c5182d7e0e4204c3bb48d9f/w/f7a4c7f2b165d95d0912b704/e/f1b534f1e34fcc8a952319e5"&gt;https://cad.onshape.com/documents/7c5182d7e0e4204c3bb48d9f/w/f7a4c7f2b165d95d0912b704/e/f1b534f1e34fcc8a952319e5&lt;/a&gt; &lt;/font&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;圖片&lt;/h2&gt;&lt;br/&gt;
下圖為我們這組機構模擬的 gif 圖檔，因為比較熟悉 solidworks 的關係，所以模擬也順便在 solidworks 裡做:
 &lt;img src="./../pictures/line/9.gif" width="800"&gt; &lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;心得&lt;/h2&gt;&lt;br/&gt;
　　因為我們一開始就選擇了較複雜的機構，所以繪製起來相對是困難一點，但經過大家分工腦力激盪後，這是我們的一點小成果，只不過為了要符合學長說列印時底板只能用木板，所以又改了一次版 ，是過程中比較麻煩的一件事，但這也是因為我們沒先事先問清楚，下次應該先注意。&lt;br/&gt;
　　為了使中間的往復機構成功，過程中參考了不少機構，最後終於回想起高中時曾經教過的卡氏圓才成功完成，剛完成的瞬間真的只有"爽"能形容。&lt;br/&gt;
　　附上成功模擬時的gif圖檔:&lt;br/&gt;
&lt;img src="./../pictures/line/10.gif" width="800"&gt; &lt;br/&gt;&lt;br/&gt;&lt;/p&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>W15課後整理</title><link href="./Course_W15_22.html" rel="alternate"></link><published>2017-10-27T12:00:00+08:00</published><updated>2017-10-27T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-27:./Course_W15_22.html</id><summary type="html">&lt;p&gt;這禮拜我們小組開始討論軌道抬球機構，附上過程圖片。&lt;br&gt;
 </summary><content type="html">&lt;p&gt;這禮拜我們小組開始討論軌道抬球機構，附上過程圖片。&lt;br&gt;
 &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;圖片&lt;/h2&gt;
 &lt;img src="./../pictures/line/1.jpg" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/2.png" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/3.png" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/4.png" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/3.png" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/5.gif" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/6.jpg" width="800"&gt; &lt;br/&gt;&lt;br/&gt;
 &lt;img src="./../pictures/line/7.jpg" width="800"&gt; &lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;心得&lt;/h2&gt;
　　一開始覺得我們太貪心了，把目標設的太大，導致機構太難，而造成繪製困難，經過幾次討論後小組慢慢有共識了。&lt;/p&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>CADP期中報告</title><link href="./40523122-midexam.html" rel="alternate"></link><published>2017-10-26T12:00:00+08:00</published><updated>2017-10-26T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-26:./40523122-midexam.html</id><summary type="html">&lt;p&gt;附上簡報的簡介與自我驗收影片。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;附上簡報的簡介與自我驗收影片。&lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;報告影片&lt;/h2&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/yA4BxElaBiU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</content><category term="exam"></category></entry><entry><title>電腦輔助設計實習第七週學習心得</title><link href="./40523122-w7-exam.html" rel="alternate"></link><published>2017-10-26T12:00:00+08:00</published><updated>2017-10-26T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-26:./40523122-w7-exam.html</id><summary type="html">&lt;p&gt;本周為期中考周，依據  &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/doc/trunk/blog/kmol-cadp-w7-exam.html"&gt;CADP 第七週線上考試&lt;/a&gt; &lt;/font&gt;&lt;/iframe&gt; 的內容完成這次的期中測驗，並附上過程影片與自評成績。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;本周為期中考周，依據  &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/doc/trunk/blog/kmol-cadp-w7-exam.html"&gt;CADP 第七週線上考試&lt;/a&gt; &lt;/font&gt;&lt;/iframe&gt; 的內容完成這次的期中測驗，並附上過程影片與自評成績。&lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;考試內容&lt;/h2&gt;
&lt;h3&gt;Exam-1&lt;/h3&gt;
第一段影片:錄下從隨身碟啟動系統開始，到完成新增第七週個人倉儲網誌中的學習心得。&lt;br/&gt;&lt;br/&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/jClfoL3kKEs" frameborder="0" gesture="media" allowfullscreen &gt;&lt;/iframe&gt;
&lt;h3&gt;Exam-2&lt;/h3&gt;
第二段影片，請根據 &lt;font color="#0066FF"&gt;&lt;a href="https://hp.kmol.info:8443/get_page/Angle%20Bracket"&gt;Angle Bracket&lt;/a&gt; &lt;/font&gt; 中的導引說明，在現場一個步驟接一個步驟，以切換說明引導的方式，錄下個人繪製零件的過程。&lt;br/&gt;&lt;br/&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/0XeeGx9-F6E" frameborder="0" gesture="media" allowfullscreen &gt;&lt;/iframe&gt;
&lt;h3&gt;Exam-3&lt;/h3&gt;
第三段影片，請利用個人先前所繪製的 Nutcracker 零件，在 Solvespace 中完成組立，每個零件的導入與定位過程均要採用 SciTE 文字說明組立所使用的約束條件與操作步驟。&lt;br/&gt;
&lt;h4&gt;&lt;font color="   #FF0000"&gt;# 操作步驟途中發生錯誤，但最後有成功修改，如要參考建議觀看  &lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/nc_set.html"&gt;Nutcracker 零件組裝過程 #影&lt;/a&gt; &lt;/font&gt;&lt;/iframe&gt; 文章中的內容。&lt;/font&gt;&lt;/h4&gt;&lt;br/&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Z-VYFLzq3Ek" frameborder="0" gesture="media" allowfullscreen &gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;自評成績 : 99&lt;/h2&gt;&lt;/p&gt;</content><category term="exam"></category></entry><entry><title>W5課後整理</title><link href="./Course_W5_22.html" rel="alternate"></link><published>2017-10-12T12:00:00+08:00</published><updated>2017-10-12T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-12:./Course_W5_22.html</id><summary type="html">&lt;p&gt;今天是第五堂課，學習 SolveSpace 也已經三禮拜了，慢慢地比較熟悉軟體操作了。上堂課完成了使用 SolveSpace 繪製 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 的八個零件，並使用限制條件組合成可做動之機構。今天的主要內容為將已繪製完成的 .stl 檔顯示在網誌中，使之可以做簡單的 3D 檢視。
</summary><content type="html">&lt;p&gt;今天是第五堂課，學習 SolveSpace 也已經三禮拜了，慢慢地比較熟悉軟體操作了。上堂課完成了使用 SolveSpace 繪製 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 的八個零件，並使用限制條件組合成可做動之機構。今天的主要內容為將已繪製完成的 .stl 檔顯示在網誌中，使之可以做簡單的 3D 檢視。
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程目標&lt;/h2&gt;
　　編輯近端檔案，使遠端網誌產生一視窗，能顯示完成之 .stl 零件檔。&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;成果展示&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/Nutcracker.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;操作步驟&lt;/h2&gt;
1. 在近端倉儲中建立一個名為 &lt;font color="#FF0088"&gt;name&lt;/font&gt; 的資料夾&lt;br/&gt;
2. 開啟 leo editor 編輯器&lt;br/&gt;
3. 建立一節點 ( Ctrl + i )，名稱為 @path ./../&lt;font color="#FF0088"&gt;name&lt;/font&gt;&lt;br/&gt;
4. 在 @path ./../&lt;font color="#FF0088"&gt;name&lt;/font&gt; 下建立兩分支節點 ( Ctrl + i -&amp;gt; Ctrl + r )，分別為 @edit viewstl.html 和 @edit jsc3d.js&lt;br/&gt;
5. @edit viewstl.html 內容為:&lt;font color="#0066FF"&gt; &lt;a href="./../viewstl.html"&gt;viewstl.html&lt;/a&gt;&lt;/font&gt; (進入後全選複製)&lt;br/&gt;
6. @edit jsc3d.js 內容為:&lt;font color="#0066FF"&gt; &lt;a href="./../jsc3d.js.html"&gt;jsc3d.js&lt;/a&gt;&lt;/font&gt;  (進入後全選複製)&lt;br/&gt;
&lt;img src="./../pictures/w5-1.PNG" width="260" high="73"/&gt;&lt;br/&gt;
7. 接下來只要在網誌內容打上
&lt;pre&gt;&lt;code&gt;&amp;lt;iframe src="./../&lt;font color="#FF0088"&gt;name&lt;/font&gt;/viewstl.html?src=&lt;font color="#7700FF"&gt;stl檔案位置&lt;/font&gt;" width="870" height="900"&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;
即可於網誌上顯示。&lt;br/&gt; &lt;/p&gt;</content><category term="notes"></category><category term="steps"></category><category term="samples"></category></entry><entry><title>Nutcracker 零件組裝過程 #影</title><link href="./nc_set.html" rel="alternate"></link><published>2017-10-11T12:00:00+08:00</published><updated>2017-10-11T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-11:./nc_set.html</id><summary type="html">&lt;p&gt;上一篇我們繪製了 nutcracker 的 8 個零件，這一篇我們將要把完成的零件以 SolveSpace 做結合限制，使之能做出我們預期之機構運動。我將影片分為上下部，分別為底座之組合與機構之組合。&lt;br/&gt;
若要繪製零件可參考上一篇: &lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/nc_draw.html"&gt;Nutcracker 零件繪製過程&lt;/a&gt;&lt;/font&gt; 的步驟。
</summary><content type="html">&lt;p&gt;上一篇我們繪製了 nutcracker 的 8 個零件，這一篇我們將要把完成的零件以 SolveSpace 做結合限制，使之能做出我們預期之機構運動。我將影片分為上下部，分別為底座之組合與機構之組合。&lt;br/&gt;
若要繪製零件可參考上一篇: &lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/nc_draw.html"&gt;Nutcracker 零件繪製過程&lt;/a&gt;&lt;/font&gt; 的步驟。
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;操作影片&lt;/h2&gt;
&lt;h3&gt;Nutcracker 組裝 (上)&lt;/h3&gt;
完成下方底座之結合限制。&lt;br/&gt;&lt;br/&gt;
&lt;h7&gt;密碼: 5487&lt;/h7&gt;&lt;br/&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/sOfUt6Z_nyw" frameborder="0" gesture="media" allowfullscreen &gt;&lt;/iframe&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h3&gt;Nutcracker 組裝 (下)&lt;/h3&gt;
完成上方機構之組裝。&lt;br/&gt;&lt;br/&gt;
&lt;h7&gt;密碼: 9487&lt;/h7&gt;&lt;br/&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/FOakltXf18Q" frameborder="0" gesture="media" allowfullscreen&gt;&lt;/iframe&gt;
&lt;br/&gt;
&lt;h3&gt; 筆記 &lt;/h3&gt;
&lt;li&gt;&lt;font color="   #FF0000"&gt; 勾選 allow redundant constraints 意思為 "允許過多的結合限制"  &lt;/font&gt;&lt;/li&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color="#BB5500" size="5"&gt;&lt;marquee scrollamount="10"&gt;喜歡我的影片請按個喜歡，想要持續追蹤也可以訂閱我哦，別忘了開起小鈴鐺，這樣每當有新片時才會第一時間通知哦!!!每天下午 5:00 不會發片，那我們下次見。&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</content><category term="video"></category></entry><entry><title>Nutcracker 零件繪製過程</title><link href="./nc_draw.html" rel="alternate"></link><published>2017-10-10T12:00:00+08:00</published><updated>2017-10-10T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-10:./nc_draw.html</id><summary type="html">&lt;p&gt;紀錄第四周回家練習之 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 八個零件的繪製過程。&lt;br/&gt;
可先參考&lt;font color="#0066FF"&gt; &lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/Course_W4_22.html"&gt;W4課後整理&lt;/a&gt; &lt;/font&gt;的課程筆記後，再觀看以下內容會比較容易上手。&lt;br/&gt;
若要組裝結合可參考下一篇: &lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/nc_set.html"&gt;Nutcracker 零件組裝過程&lt;/a&gt;&lt;/font&gt; 的內容。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄第四周回家練習之 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 八個零件的繪製過程。&lt;br/&gt;
可先參考&lt;font color="#0066FF"&gt; &lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/Course_W4_22.html"&gt;W4課後整理&lt;/a&gt; &lt;/font&gt;的課程筆記後，再觀看以下內容會比較容易上手。&lt;br/&gt;
若要組裝結合可參考下一篇: &lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/doc/trunk/blog/nc_set.html"&gt;Nutcracker 零件組裝過程&lt;/a&gt;&lt;/font&gt; 的內容。&lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;目錄&lt;/h2&gt;
&lt;li&gt;&lt;a href="#base"&gt;&lt;font color="#227700"&gt;Base 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#handle"&gt;&lt;font color="#227700"&gt;Handle 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#adjuster"&gt;&lt;font color="#227700"&gt;Adjuster 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#piston"&gt;&lt;font color="#227700"&gt;Piston 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cylinder"&gt;&lt;font color="#227700"&gt;Cylinder 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#hinge"&gt;&lt;font color="#227700"&gt;Hinge 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#adjuster_base"&gt;&lt;font color="#227700"&gt;Adjuster_base 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#connection"&gt;&lt;font color="#227700"&gt;Connection 繪製過程&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;a id="base"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Base 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/base.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
&lt;font size="4"&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;
&lt;font color="#FF0000"&gt;# 可用建構線輔助矩形之中心定位。&lt;/font&gt;&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/base-1.png" width="715"&gt; &lt;br/&gt;&lt;br/&gt;
2. 填料長出 0.375 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/base-2.png" width="715"&gt; 
&lt;a id="handle"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Handle 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/handle.stl" width="870" height="700"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-1.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt; 
2. 伸長填料 7.5 。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-2.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt; 
3. 選擇如下圖中之兩線一點，建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-3.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt; 
4. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-4.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt; 
5. 伸長除料 5.0 。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-5.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt; 
6. 選擇如下圖中之兩線一點，再建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-6.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt;
7. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-7.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt;
8. 伸長除料。&lt;br/&gt;
 &lt;font color="#FF0000"&gt;# 選擇 difference 除料。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-8.png" width="715"/&gt;&lt;br/&gt;&lt;br/&gt;
9.選擇如下圖中一點一面，重合 ( O ) 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/handle-9.png" width="715"/&gt;
&lt;a id="adjuster"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Adjuster 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/adjuster.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖，後點選圖中中線為旋轉軸，旋轉填料。&lt;br/&gt;
&lt;font color="#FF0000"&gt;# 以圖中中線為對稱軸，畫出建構線輔助尺寸之標示。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster-1.png" width="715"&gt;&lt;br/&gt; &lt;br/&gt;
2. 選擇如下圖中之兩線一點，建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster-2.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
3. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster-3.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
4. 選擇半圓之底線旋轉除料後便完成。&lt;br/&gt;
 &lt;font color="#FF0000"&gt;# 選擇 difference 除料。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster-4.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
5. 若如下圖中產生紅色之干涉現象，可勾選 force NURBS surfaces to triangle mesh 解決。&lt;br/&gt; &lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster-5.png" width="715"&gt;
&lt;a id="piston"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Piston 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/piston.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖，後點選圖中紅線為旋轉軸，旋轉填料。&lt;br/&gt;
&lt;font color="#FF0000"&gt;# 以圖中紅線為對稱軸，畫出建構線輔助尺寸之標示。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-1.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
2. 選擇如下圖中之點，於端面建立新草圖 (Shift + w )。&lt;br/&gt; &lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-2.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
3. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-3.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
4. 伸長除料 1.0 。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-4.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
5. 選擇如下圖中之兩線一點，再建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-5.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
6. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-6.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
7. 伸長除料，選擇如下圖中一點一面，重合 ( O )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-7.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
8. 選擇如下圖中之兩線一點，再建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-8.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
9. 於新草圖上繪出如工程圖所表達，後如同 Adjuster 繪製過程之步驟4、5，便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/piston-9.png" width="715"&gt;
&lt;a id="cylinder"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Cylinder 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/cylinder.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/cylinder-1.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
2. 填料長出 3.0 。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/cylinder-2.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
3. 選擇如下圖中之兩線一點，建立新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/cylinder-3.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
4. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/cylinder-4.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
5. 除料伸長 0.5 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/cylinder-5.png" width="715"&gt;
&lt;a id="hinge"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Hinge 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/hinge.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-1.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
2. 填料長出 0.75 。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-2.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
3. 選擇如下圖中之兩線一點，建立新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-3.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
4. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;
&lt;font color="#FF0000"&gt;# 使用建構線輔助圓形之中心定位。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-4.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
5. 伸長除料，選擇如下圖中一點一面，重合 ( O )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-5.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
6. 選擇如下圖中之兩線一點，再建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-6.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
7. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-7.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
8. 伸長除料 0.5 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/hinge-8.png" width="715"&gt;
&lt;a id="adjuster_base"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Adjuster_base 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/adjuster_base.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster_base-1.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
2. 伸長填料1.0。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster_base-2.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
3. 選擇如下圖中之兩線一點，建立一個新草圖 (Shift + w )。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster_base-3.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
4. 於新草圖上繪出如工程圖所表達。&lt;br/&gt;
&lt;font color="#FF0000"&gt;# 以圖中紅線為對稱軸，使兩側之圓對稱。&lt;br/&gt;&lt;/font&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster_base-4.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt; 
5. 除料伸長 0.25 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/adjuster_base-5.png" width="715"&gt;
&lt;a id="connection"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;Connection 繪製過程&lt;/h2&gt;
&lt;iframe src="./../stlviewer/viewstl.html?src=./../stl/connection.stl" width="870" height="900"&gt;&lt;/iframe&gt;&lt;br/&gt;
1. 照著工程圖所標示之尺寸於前基準面繪出，如下圖。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/connection-1.png" width="715"&gt;&lt;br/&gt;&lt;br/&gt;
 2. 伸長填料 0.25 後便完成。&lt;br/&gt;&lt;br/&gt;
&lt;img src="./../pictures/nutcracker/connection-2.png" width="715"&gt; 
&lt;/font&gt;&lt;/p&gt;</content><category term="steps"></category><category term="samples"></category></entry><entry><title>W4課後整理</title><link href="./Course_W4_22.html" rel="alternate"></link><published>2017-10-05T12:00:00+08:00</published><updated>2017-10-05T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-10-05:./Course_W4_22.html</id><summary type="html">&lt;p&gt;第四堂課也正式開始了本學期的內容，今天的內容主要為 SolveSpace 零件繪圖、組合教學，使用 SolveSpace 而不使用 Solidworks 或 Inventor 之類的繪圖軟體的原因為相較其他起來 SolveSpace 檔案容量更小，約只有 6.3 Mb ，雖然功能陽春點，但攜帶方便，更能凸顯出工程師隨處設計之理念。&lt;br/&gt; &lt;/p&gt;
</summary><content type="html">&lt;p&gt;第四堂課也正式開始了本學期的內容，今天的內容主要為 SolveSpace 零件繪圖、組合教學，使用 SolveSpace 而不使用 Solidworks 或 Inventor 之類的繪圖軟體的原因為相較其他起來 SolveSpace 檔案容量更小，約只有 6.3 Mb ，雖然功能陽春點，但攜帶方便，更能凸顯出工程師隨處設計之理念。&lt;br/&gt; &lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程目標&lt;/h2&gt;
　　學習 SolveSpace 的基本繪畫功能，將 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 的 8 個零件繪出，並加以組裝，使之能做出預設之動作，之後使用 File -&amp;gt;  Export Triangle Mesh 轉為 .stl 檔，再使用vrep開啟模擬。   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程筆記&lt;/h2&gt;
&lt;h3&gt;SolveSpace 基本功能簡介&lt;/h3&gt;
&lt;div align=center style="width: 800"&gt;
&lt;div style="width: 90; float:left"&gt;&lt;img src="./../pictures/basic_area.png" width="85" high="215"&gt;&lt;div&gt;圖 (1)&lt;/div&gt;&lt;/div&gt;
&lt;div align=center style="width: 90; float:left; margin-left: 20px"&gt;&lt;img src="./../pictures/limit_area.png" width="83" high="260"&gt;&lt;div&gt;圖 (2)&lt;/div&gt;&lt;/div&gt;
&lt;div align=center style="width: 90; float:left; margin-left: 20px"&gt;&lt;img src="./../pictures/feature_area.png" width="85" high="181"&gt;&lt;div&gt;圖 (3)&lt;/div&gt;&lt;/div&gt;
&lt;div style="clear:both"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div style="clear:left"&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;font size="5"&gt;圖 (1) 描述&lt;/font&gt;&lt;br/&gt;
&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;font size="4"&gt;左排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;右排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;直線&lt;/th&gt;
            &lt;th&gt;畫出直線&lt;/th&gt;
            &lt;th&gt;矩形&lt;/th&gt;
            &lt;th&gt;畫出矩形&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;圓&lt;/th&gt;
            &lt;th&gt;畫出圓&lt;/th&gt;
            &lt;th&gt;弧&lt;/th&gt;
            &lt;th&gt;選擇起始和終點畫弧&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;文字&lt;/th&gt;
            &lt;th&gt;打出文字 (只能英文，文字由 Property Browser 改)&lt;/th&gt;
            &lt;th&gt;導圓角&lt;/th&gt;
            &lt;th&gt;先選一交點後再點選圖示，由交點處導圓角&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;曲線&lt;/th&gt;
            &lt;th&gt;畫出曲線&lt;/th&gt;
            &lt;th&gt;點&lt;/th&gt;
            &lt;th&gt;畫出一點&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;建構線&lt;/th&gt;
            &lt;th&gt;選取一線，將之轉為建構線 (綠線，輔助用)&lt;/th&gt;
            &lt;th&gt;分割&lt;/th&gt;
            &lt;th&gt;先點選兩線後再點選圖示 (將兩線由交點分割)&lt;/th&gt;
        &lt;/tr&gt;&lt;br/&gt;
    &lt;/table&gt;&lt;br/&gt;
    &lt;font size="5"&gt;圖 (2) 描述&lt;/font&gt;&lt;br/&gt;
&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;font size="4"&gt;左排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;右排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;標註尺寸&lt;/th&gt;
            &lt;th&gt;先選取兩點或一點一線再點選圖示，量取距離，雙擊修改尺寸 (不可選擇兩線)&lt;/th&gt;
            &lt;th&gt;標註角度&lt;/th&gt;
            &lt;th&gt;先選取兩線再點選圖示，量取角度，雙擊修改尺寸&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;水平&lt;/th&gt;
            &lt;th&gt;選取一線使之水平，或選取兩點，讓兩點相對水平&lt;/th&gt;
            &lt;th&gt;豎直&lt;/th&gt;
            &lt;th&gt;選取一線使之豎直，或選取兩點，讓兩點相對豎直&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;平行&lt;/th&gt;
            &lt;th&gt;選取兩線使之相對平行&lt;/th&gt;
            &lt;th&gt;直角&lt;/th&gt;
            &lt;th&gt;選取兩線使之互相呈直角&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;交點&lt;/th&gt;
            &lt;th&gt;選取兩點，使兩點重合，或一點一線，使點置於線上&lt;/th&gt;
            &lt;th&gt;對稱&lt;/th&gt;
            &lt;th&gt;選取兩點一線，使兩點對選擇線 (基準線) 對稱&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;等長&lt;/th&gt;
            &lt;th&gt;選取兩線，使兩線等長&lt;/th&gt;
            &lt;th&gt;法線方向固定&lt;/th&gt;
            &lt;th&gt;選擇兩法線，使之為相同方向&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;補角&lt;/th&gt;
            &lt;th&gt;選取一角度尺寸，呈現此角度之補角&lt;/th&gt;
            &lt;th&gt;鎖定尺寸&lt;/th&gt;
            &lt;th&gt;選擇一標註尺寸，使之為從動尺寸 (可跟隨移動)&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/table&gt;&lt;br/&gt;
    &lt;br/&gt;
&lt;font size="5"&gt;圖 (3) 描述&lt;/font&gt;&lt;br/&gt;
&lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;font size="4"&gt;左排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;右排&lt;/font&gt;&lt;/th&gt;
            &lt;th&gt;&lt;font size="4"&gt;描述&lt;/font&gt;&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;伸長&lt;/th&gt;
            &lt;th&gt;伸長填料。伸長除料，由 Property Browser 改 ( solid model as 改 difference )&lt;/th&gt;
            &lt;th&gt;旋轉&lt;/th&gt;
            &lt;th&gt;先選擇一線當基準線後再點選圖示，旋轉填料。旋轉除料，由 Property Browser 改 ( solid model as 改 difference )&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;環形陣列&lt;/th&gt;
            &lt;th&gt;先選擇一點再點選圖示，畫面所有圖形以點為圓心環形陣列 (數量由 Property Browser 改)&lt;/th&gt;
            &lt;th&gt;直線陣列&lt;/th&gt;
            &lt;th&gt;點選後畫面所有圖形直線陣列 (數量由 Property Browser 改)&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;平面草圖&lt;/th&gt;
            &lt;th&gt;先點選兩點一線後再點選圖示，以兩點一線圍成之面為草圖平面&lt;/th&gt;
            &lt;th&gt;3D 草圖&lt;/th&gt;
            &lt;th&gt;可在空間任意地方畫圖 (線用直線、圓、曲線)&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;組合圖檔&lt;/th&gt;
            &lt;th&gt;點選後開啟資料夾，選取所需組合之零件，將之載入目前視圖中以供組合&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;     &lt;br&gt;
    &lt;/table&gt;&lt;br/&gt;
&lt;h3&gt;SolveSpace 小技巧&lt;/h3&gt;
1. 欲使一圓心至於一正方形中心時，可先畫一方型後，在任意位置畫上兩點，接著點選一點一邊後按 M ，使點置於邊線中央，如圖 (4)，接著點選圓心和第一點 -&amp;gt; 水平，圓心和第二點 -&amp;gt; 豎直後即可，如圖 (5)。
&lt;div align=center style="width: 800"&gt;
&lt;div style="width: 305; float:left"&gt;&lt;img src="./../pictures/circle_middle-1.PNG" width="299" hight="319"&gt;&lt;div&gt;圖 (4)&lt;/div&gt;&lt;/div&gt;
&lt;div align=center style="width: 305; float:left; margin-left: 20px"&gt;&lt;img src="./../pictures/circle_middle-2.PNG" width="295" hight="319"&gt;&lt;div&gt;圖 (5)&lt;/div&gt;&lt;/div&gt;
&lt;div style="clear:both"&gt;&lt;/div&gt;
&lt;/div&gt;
2. 欲使圓柱體之頂面能繪製草圖時，可先在未伸長前之草圖畫兩建構線通過圓心至邊線，一條水平，一條豎直，如圖 (6)，即可在伸長後之面有一面(兩線一點)可繪製草圖，如圖 (7)。
&lt;div align=center style="width: 800"&gt;
&lt;div style="width: 300; float:left"&gt;&lt;img src="./../pictures/circle_g-1.PNG" width="300" hight="300"&gt;&lt;div&gt;圖 (6)&lt;/div&gt;&lt;/div&gt;
&lt;div align=center style="width: 300; float:left; margin-left: 20px"&gt;&lt;img src="./../pictures/circle_g-2.PNG" width="300" hight="300"&gt;&lt;div&gt;圖 (7)&lt;/div&gt;&lt;/div&gt;
&lt;div style="clear:both"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;h3&gt;Vrep 前置操作&lt;/h3&gt;
1. 開啟後，File -&amp;gt; Import -&amp;gt; Mesh... 開啟檔案 ( .stl ) ，開啟後可選擇比例和方向，確定後即完成檔案置入。&lt;br/&gt;
2. 接著可使用 Edit -&amp;gt; Grouping/Merging -&amp;gt; Divide selected shapes 將組合件分解成零件。&lt;br/&gt;
3. 雙擊零件名稱旁的圖示開啟一視窗 圖 (8)，點選 Show dynamic properties dialog ，勾選 Body is respondable -&amp;gt; 零件實體化，勾選 Body is dynamic -&amp;gt; 零件產生重力。
&lt;div align=center style="width: 800"&gt;
&lt;div style="width: 395; float:left"&gt;&lt;img src="./../pictures/vrep_setting-1.PNG" width="395" hight="305"&gt;&lt;div&gt;圖 (8)&lt;/div&gt;&lt;/div&gt;
&lt;div style="clear:both"&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;</content><category term="notes"></category><category term="tips"></category></entry><entry><title>W3課後整理</title><link href="./Course_W3_22.html" rel="alternate"></link><published>2017-09-28T12:00:00+08:00</published><updated>2017-09-28T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-09-28:./Course_W3_22.html</id><summary type="html">&lt;p&gt;本堂課是學期第三堂，也是前三周適應期的最後一堂，過了這堂課就要開始這門課的重點了，今天的內容為將前兩周未完成事項完成，並說明接下來的課程所需使用的 SolveSpace 和 Vrep 這兩套軟體，及調整好心態來準備、面對接下來會遇到的問題與工作。&lt;br/&gt;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;本堂課是學期第三堂，也是前三周適應期的最後一堂，過了這堂課就要開始這門課的重點了，今天的內容為將前兩周未完成事項完成，並說明接下來的課程所需使用的 SolveSpace 和 Vrep 這兩套軟體，及調整好心態來準備、面對接下來會遇到的問題與工作。&lt;br/&gt;&lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程目標&lt;/h2&gt;
　　將前兩堂課未完成的內容完成，確定個人倉儲首頁有連結能點選進入個人 Blog ，確定能使用 leo editor 編輯網誌並回推遠端，確定每周回家練習並將心得打成網誌更新，學習 SolveSpace 基礎繪圖技巧，如何配合 SolveSpace 和 Vrep 將零件組成機構以供接下來的課程使用。&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程筆記&lt;/h2&gt;
　　首先練習依照 &lt;font color="#0066FF"&gt;&lt;a href="https://mde1a1.kmol.info/2017fall/raw/ProEMechanism.pdf?name=a48a8c10af4e636b37ff9c8bc6e98ff00af0ac44"&gt;Nutcracker&lt;/a&gt; &lt;/font&gt; 連結中的工程圖， 將零件以 SolveSpace 畫出，試著嘗試使用 SolveSpace 內的各種功能，並可參考 &lt;font color="#0066FF"&gt;&lt;a href="http://solvespace.com/index.pl"&gt;SolveSpace 說明&lt;/a&gt; &lt;/font&gt;或&lt;a href="https://hp.kmol.info:8443/get_page/Angle%20Bracket"&gt;草圖指引&lt;/a&gt;內的說明，並且練習利用 &lt;a href="https://hp.kmol.info:8443/get_page/Assembly"&gt;組立指引&lt;/a&gt; 練習組立，一步步了解程式的使用方式。&lt;br/&gt;
畫完的零件可用 File -&amp;gt;  Export Triangle Mesh 轉為 .stl 檔，之後將 .stl 檔丟到 vrep 中做進階之動作分析。&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;SolveSpace 小技巧&lt;/h2&gt;
1. W -&amp;gt; 將畫面正視於最近平面&lt;br/&gt;
2. 先選兩點(一點一線)後 D -&amp;gt; 標尺寸 &lt;font color="#FF0000"&gt;# 不能選取兩線&lt;/font&gt;&lt;br/&gt;
3. 先選取兩線一點後 shift + w -&amp;gt; 於兩線一點所建構之面建立草圖&lt;br/&gt;
4. 先選取一點一線後 M -&amp;gt; 將選取之點至於線段中點&lt;br/&gt;
5. 選一線後 G -&amp;gt; 將選取之線轉為建構線 (綠線)&lt;br/&gt;
6. tab -&amp;gt; 將 Property Browser 關閉 (也就是除了主視窗外旁邊的小視窗)&lt;br/&gt;
7. 選取一點後 Ctrl + Shift + T -&amp;gt; 將接下來選取之點移動路徑畫出&lt;br/&gt;
　　&lt;/p&gt;</content><category term="notes"></category><category term="tips"></category></entry><entry><title>W2課後整理</title><link href="./Course_W2_22.html" rel="alternate"></link><published>2017-09-21T12:00:00+08:00</published><updated>2017-09-21T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-09-21:./Course_W2_22.html</id><summary type="html">&lt;p&gt;本堂課是學期第二堂，還在前三周的適應期，所以今天的內容跟第一周內容類似，目的使同學們能更快適應並跟上課程進度。&lt;br/&gt;
今天的內容主要為學習如何進一步管理遠端倉儲。&lt;br/&gt;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;本堂課是學期第二堂，還在前三周的適應期，所以今天的內容跟第一周內容類似，目的使同學們能更快適應並跟上課程進度。&lt;br/&gt;
今天的內容主要為學習如何進一步管理遠端倉儲。&lt;br/&gt;&lt;/p&gt;


&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程目標&lt;/h2&gt;
　　將第一堂課未完成的內容完成，編輯 leo editor 中 Pelican 遠端的設定，使遠端 Blog 連結為最新內容，新增 gitjub-blog 按鈕用途，了解 fossil status 和 fossil delete 。  &lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程筆記&lt;/h2&gt;
&lt;h3&gt;編輯 leo editor 中 Pelican 遠端的設定&lt;/h3&gt;
　　使用 SciTE 載入 Y:\launchLeo.py 後 F5 將 leo editor 開啟，用 leo editor 開啟位於 users 內的 .leo 檔案，找到 @path ../Pelican 設定/遠端/@edit publishconf.py 檔案: 
&lt;pre&gt;&lt;code&gt;# 將所有靜態 html 檔案移到 blog 子目錄
SITEURL = '&lt;font color="#00AA00"&gt;url&lt;/font&gt;'&lt;/code&gt;&lt;/pre&gt;
將內容的 &lt;font color="#00AA00"&gt;url&lt;/font&gt; 改成&lt;font color="#7700FF"&gt;倉儲位址/doc/trunk/blog&lt;/font&gt;，範例:&lt;font color="#7700FF"&gt; https://cadpa.kmol.info/40523122/doc/trunk/blog &lt;/font&gt;，即可使連結改為最新版本。 &lt;br/&gt;
&lt;font color="   #FF0000"&gt;# doc 為 document 簡稱，表示能將資料夾內的超文件解開至瀏覽器。 trunk 為最新版的意思。&lt;/font&gt;&lt;br/&gt;
&lt;h3&gt;新增 gitjub-blog 按鈕用途&lt;/h3&gt;
　　與以往使用的 pelican-blog 按鈕區分為，新版的 gitjub-blog 按鈕新增了討論留言區， 至於文章最下方，並注意&lt;font color="    #FF0000"&gt;留言區會跟隨文章所在的 slug ，所以盡量別跟別人有重複的 slug 。&lt;/font&gt;&lt;br/&gt;
&lt;h3&gt;fossil status 和 fossil delete &lt;/h3&gt;
　　fossil status 為查看目前所在資料夾檔案狀況的指令，若資料內容出現 missing 表示資料已遭更改刪除，必須以 fossil delete 處理，才能繼續後續之動作。&lt;br/&gt;
　　fossil delete 範例: 若要刪除 data 內的 sample.py 指令如下
&lt;pre&gt;&lt;code&gt;fossil delete data/sample.py&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</content><category term="notes"></category><category term="command"></category></entry><entry><title>W1課後整理</title><link href="./Course_W1_22.html" rel="alternate"></link><published>2017-09-14T12:00:00+08:00</published><updated>2017-09-14T12:00:00+08:00</updated><author><name>40523122</name></author><id>tag:None,2017-09-14:./Course_W1_22.html</id><summary type="html">&lt;p&gt;本學期課程為上學期之延伸，使用到上學期所操作的 Fossil SCM 與 Stunnel 。&lt;br/&gt;
前三周為適應期，目的使我們練習並更熟悉如何使用課堂工具，以提高接下來工作完成的效率。&lt;br/&gt;
</summary><content type="html">&lt;p&gt;本學期課程為上學期之延伸，使用到上學期所操作的 Fossil SCM 與 Stunnel 。&lt;br/&gt;
前三周為適應期，目的使我們練習並更熟悉如何使用課堂工具，以提高接下來工作完成的效率。&lt;br/&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;課程目標&lt;/h2&gt;&lt;br/&gt;
　　第一堂課先從 &lt;font color="#0066FF"&gt;&lt;a href="http://service.mde.tw/public/python2017fall_36.7z"&gt;python2017fall_36&lt;/a&gt;&lt;/font&gt; 下載本學期所需的工具解壓縮至隨身碟中，以 start.bat 批次檔啟動後，管理個人在&lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info"&gt; https://cadpa.kmol.info &lt;/a&gt; &lt;/font&gt; 的倉儲，並利用 leo-editor 創建一個 Blog 後，將Blog連結至於首頁。&lt;br/&gt;
&lt;br/&gt;
我的倉儲連結:&lt;font color="#0066FF"&gt;&lt;a href="https://cadpa.kmol.info/40523122/index"&gt; https://cadpa.kmol.info/40523122/index &lt;/a&gt; &lt;/font&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;操作步驟&lt;/h2&gt;&lt;br/&gt;
1.  下載網站內容並附加&lt;font color="#7700FF"&gt;帳號&lt;/font&gt;資訊 &lt;br/&gt;
&lt;pre&gt;&lt;code&gt; fossil clone https://&lt;font color="#7700FF"&gt;帳號&lt;/font&gt;@url &lt;font color="#00AA00"&gt;name.fossil&lt;/font&gt; &lt;/code&gt;&lt;/pre&gt;
&lt;font color="   #FF0000"&gt;# 此時會在所在資料夾產生一個檔案名稱為 &lt;font color="#00AA00"&gt;name.fossil&lt;/font&gt; 的檔案。&lt;/font&gt;&lt;br/&gt;
2.  打密碼並在記住密碼時選擇 n (不要記住密碼)&lt;br/&gt;
&lt;img src="./../pictures/remember_no.png" width="438" high="59"/&gt;&lt;br/&gt;
3.  創一個名為 &lt;font color="#FF0088"&gt;data&lt;/font&gt; 的資料夾&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;mkdir &lt;font color="#FF0088"&gt;data&lt;/font&gt;&lt;/code&gt;&lt;/pre&gt;
4.  進入 &lt;font color="#FF0088"&gt;data&lt;/font&gt;&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;cd &lt;font color="#FF0088"&gt;data&lt;/font&gt;&lt;/code&gt;&lt;/pre&gt;
5.  開啟 &lt;font color="#00AA00"&gt;name.fossil&lt;/font&gt; 到 &lt;font color="#FF0088"&gt;data&lt;/font&gt; 內&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;fossil open ./../&lt;font color="#00AA00"&gt;name.fossil&lt;/font&gt; &lt;/code&gt;&lt;/pre&gt;
6.  將要上傳的東西複製進 &lt;font color="#FF0088"&gt;data&lt;/font&gt; 內&lt;br/&gt;
7.使用 SciTE 開啟 Leo editor&lt;br/&gt;
&lt;img src="./../pictures/open_leo.png" width="378" high="490"/&gt; &lt;br&gt;
8.編輯 .leo &lt;br/&gt;
9.  加入所有更動&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;fossil add . &lt;/code&gt;&lt;/pre&gt;
10.  提交標題名稱為 &lt;font color="#BB5500"&gt;message&lt;/font&gt; 的內容&lt;br/&gt;
&lt;pre&gt;&lt;code&gt;fossil commit -m "&lt;font color="#BB5500"&gt;message&lt;/font&gt;"&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;h2&gt;操作影片&lt;/h2&gt;&lt;p&gt;(影片載入約需30秒)&lt;/p&gt;&lt;br/&gt;
&lt;video id="movie" preload controls loop  width="960" height="515"&gt;
  &lt;source src="./../videos/w1_video.mp4" type="video/mp4" /&gt;
&lt;/video&gt;&lt;/p&gt;</content><category term="notes"></category><category term="command"></category><category term="steps"></category><category term="videos"></category></entry></feed>